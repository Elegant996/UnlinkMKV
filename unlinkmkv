#!/usr/bin/env perl
# unlinkmkv - Because de-douche was too on the nose.

require 5.010;
use strict;
use warnings;
use XML::LibXML;
use File::Basename;
use Cwd            qw/realpath/;
use File::Glob     qw/:globally :nocase/;
use Math::BigFloat qw/:constant/;
use Getopt::Long;

    my $tmpdir;
    my $file;
    my $outfile;
    my $rename        = 0;
    my $replace       = 0;
    my $keeptempfiles = 0;
    my $verbose       = 0;
    my $toolpath      = "/usr/bin";
    my $ffmpeg        = "/opt/ffmpeg/bin/ffmpeg";

    GetOptions (
	"tmpdir=s"       => \$tmpdir,
	"o|out=s"        => \$outfile,
	"rename-old!"    => \$rename,
	"replace!"       => \$replace,
	"keeptempfiles!" => \$keeptempfiles,
	"toolpath"       => \$toolpath,
	"verbose|v"      => \$verbose,
    );

    print "please specify a file or directory\n"                      and exit(0) if !defined $ARGV[0];
    print "specified file or directory does not appear to be valid\n" and exit(0) unless (-s $ARGV[0] || -d $ARGV[0]);

    $toolpath     =~ s/\/?$/\//;
    my $mkvext    = $toolpath . 'mkvextract';
    my $mkvinfo   = $toolpath . 'mkvinfo';
    my $mkvmerge  = $toolpath . 'mkvmerge';
    my $xmlparser = XML::LibXML->new();
    $tmpdir       = (defined $tmpdir) ? $tmpdir: '/tmp';
    $tmpdir       =~ s/\/$//;

    if(-f $ARGV[0]) {
	process_file($ARGV[0]);
    }
    elsif(-d $ARGV[0]) {
	my $segfiles;
	my $work_dir = realpath($ARGV[0]);
	opendir(my $dh, $work_dir) || die "failed to open directory $!";
	while(my $file = readdir $dh) {
	    open my $FH, '-|', $mkvext, 'chapters', $file;
	    while(my $line = <$FH>) {
		if($line =~ /<ChapterSegmentUID/) {
		    $segfiles->{$file} = 1;
		}
	    }
	    close $FH;
	}
	closedir($dh);
	chdir($work_dir);
	foreach my $file (sort keys %$segfiles) {
	    process_file($file, $outfile);
	}
    }
    exit(0);

    sub process_file {
	my $arg_file = shift;
	my $outfile  = shift;
	my($parent, $dir, $suffix) = fileparse($arg_file, qr/\.[mM][kK][vV]/);
	$dir                       = realpath($dir);
	$file                      = "$dir/$parent$suffix";
	$outfile                 //= "$parent.REBUILT$suffix";

	if($outfile =~ /\//) {
	    my($f, $d, $s) = fileparse($arg_file, qr/\.[mM][kK][vV]/);
	    $d = realpath($dir);
	    if(-d $d) {
		$outfile = "$d/$outfile";
	    }
	    else {
		print "unable to resolve path for outfile, please either use an absolute path or just the filename";
		exit;
	    }
	}
	else {
	    $outfile = "$dir/$outfile";
	}

	my $xml;
	my @segments;
	my @splits;
	my @cleanuplist;

	print "processing $parent$suffix\n";

	open my $H, '-|', $mkvext, 'chapters', $file;
	binmode $H;
	$xml = $xmlparser->load_xml(IO => $H);
	close $H;

	my $offs_time_end            = '00:00:00.000000000';
	my $last_time_end            = '00:00:00.000000000';
	my $offset                   = '00:00:00.000000000';
	foreach my $chapter ($xml->findnodes('//ChapterAtom')) {
	    my ($ChapterTimeStart) = $chapter->findnodes('./ChapterTimeStart/text()');
	    my ($ChapterTimeEnd)   = $chapter->findnodes('./ChapterTimeEnd/text()');
	    if($chapter->exists('ChapterSegmentUID') && $chapter->findvalue('ChapterFlagEnabled') == 1) {
		my ($SegmentUID, $SegmentELE, $SegmentUIDText);
		($SegmentELE)   = $chapter->findnodes('./ChapterSegmentUID');
		($SegmentUID)   = $chapter->findnodes('./ChapterSegmentUID/text()');
		$SegmentUIDText = $SegmentUID->textContent();
		if($SegmentELE->getAttribute('format') eq 'hex') {
		    $SegmentUIDText =~ s/\n//g;
		    $SegmentUIDText =~ s/\s//g;
		    $SegmentUIDText =~ s/([a-zA-Z0-9]{2})/ 0x$1/g;
		    $SegmentUIDText =~ s/^\s//;
		}
		elsif($SegmentELE->getAttribute('format') eq 'ascii') {
		    $SegmentUIDText =~ s/(.)/sprintf("0x%x ",ord($1))/eg;
		    $SegmentUIDText =~ s/\s$//;
		}
		push @segments, {
		    start       => $ChapterTimeStart->textContent(),
		    stop        => $ChapterTimeEnd->textContent(),
		    id          => $SegmentUIDText,
		    split_start => $last_time_end
		};
		push @splits, $last_time_end unless $last_time_end eq '00:00:00.000000000';
		$chapter->removeChild($chapter->findnodes('./ChapterSegmentUID'));
		$offset = add_duration_to_timecode($offset, $ChapterTimeEnd->textContent());
		$ChapterTimeStart->setData($offs_time_end);
		$ChapterTimeEnd->setData(add_duration_to_timecode($offs_time_end, $ChapterTimeEnd->textContent()));
	    }
	    else {
		eval { if(defined $ChapterTimeEnd->textContent() && defined $ChapterTimeStart->textContent()){}; 1 } or next;
		push @segments, {
		    file        => $dir . '/' . $parent . $suffix,
		    start       => $ChapterTimeStart->textContent(),
		    stop        => $ChapterTimeEnd->textContent(),
		    split_start => $ChapterTimeStart->textContent(),
		    split_stop  => $ChapterTimeEnd->textContent()
		};
		$last_time_end = $ChapterTimeEnd->textContent();
		$ChapterTimeStart->setData(add_duration_to_timecode($ChapterTimeStart->textContent(), $offset));
		$ChapterTimeEnd->setData(add_duration_to_timecode($ChapterTimeEnd->textContent(),     $offset));
		$offs_time_end = $ChapterTimeEnd->textContent();
	    }
	}

	open my $out_chapters, '>', $tmpdir . "/$parent-chapters.xml";
	print {$out_chapters} $xml->toString;
	close $out_chapters;
	push @cleanuplist, $tmpdir . "/$parent-chapters.xml";

	chdir($dir);
	foreach my $mkv (<*.mkv>) {
	    $mkv = "$dir/$mkv";
	    next if $mkv eq $file;
	    my ($id, $dur) = mkvinfo($mkv);
	    for (@segments) {
		next unless defined $_->{id};
		if($_->{id} eq $id) {
		    $_->{file} = $mkv;
		}
	    }
	}

	my $okay_to_proceed = 1;
	for (@segments) {
	    if(defined $_->{id} && !defined $_->{file}) {
		printf("\t%-15s: %s\n","missing segment", $_->{id});
		$okay_to_proceed = 0;
	    }
	    elsif(defined $_->{id} && defined $_->{file}) {
		printf("\t%15s: %s\n","found segment", $_->{file});
	    }
	}
	if(!$okay_to_proceed) {
	    cleanup(@cleanuplist);
	    return 0;
	}

	if(scalar(@splits) > 0) {
	    my @mergeout;
	    printf("\t%15s: %s\n","splitting file", $file) unless scalar(@splits) == 0;
	    open my $M, '-|', $mkvmerge, '--no-chapters', '-o', "$tmpdir/$parent-unlinkmkv-%03d.mkv", $file, '--split', 'timecodes:' . join(',',@splits);
	    while(<$M>) {
		print if $verbose;
		chomp;
		push @mergeout, $_;
	    }
	    close $M;
	}

	my @parts;
	my $LAST  = '';
	my $count = 1;
	foreach my $segment (@segments) {
	    if(defined $segment->{id} && $segment->{start} eq '00:00:00.000000000' || ($LAST ne $segment->{file} && scalar(@splits) == 0)) {
		push @parts, '+';
		push @parts, $segment->{file};
	    }
	    elsif($LAST ne $segment->{file}) {
		push @parts,       '+';
		push @parts,       sprintf("$tmpdir/$parent-unlinkmkv-%03d.mkv",$count);
		push @cleanuplist, sprintf("$tmpdir/$parent-unlinkmkv-%03d.mkv",$count);
		$count++;
	    }
	    $LAST = $segment->{file};
	}
	(undef) = shift @parts;

	my @mergeout;
	printf("\t%15s: %s\n","building file", $outfile);
	open my $MERGE, '-|', $mkvmerge, '--no-chapters', '--chapters', "$tmpdir/$parent-chapters.xml", '-o', $outfile, @parts;
	while(<$MERGE>) {
	    print if $verbose;
	    chomp;
	    push @mergeout, $MERGE;
	}
	close $MERGE;

	printf("\t%15s: %s\n","move source to", "$file.unlinkmkv") if $rename;
	system('/bin/mv',       $file,   "$file.unlinkmkv")        if $rename;
	printf("\t%15s: %s\n","save final as", $file)              if $replace;
	system('/bin/mv', '-f', $outfile, $file)                   if $replace;

	cleanup(@cleanuplist);
    }

    sub cleanup {
	my (@cleanuplist) = @_;
	if(!$keeptempfiles) {
	    for (@cleanuplist) {
		printf("\t%15s: %s\n", 'removing', $_);
		system('rm','-f',$_);
	    }
	}
    }

    sub mkvinfo {
	my $file = shift;
	open my $H, '-|', $mkvinfo, $file;
	my $id  = '';
	my $dur = '';
	while(<$H>) {
	    chomp;
	    if ($_ =~ /Segment UID:/) {
		$_ =~ /Segment UID:([a-zA-Z0-9\s]+)$/;
		$id = $1;
		$id =~ s/^\s+//g;
		$id =~ s/\s+$//g;
	    }
	    elsif($_ =~ /^\| \+ Duration:/) {
		$_   =~ /^\| \+ Duration:.*\((.*)\)/;
		$dur = $1;
	    }
	}
	close $H;
	return ($id, $dur);
    }

    sub add_duration_to_timecode {
	my $time = shift;
	my $dur  = shift;
	my ($th, $tm, $ts) = split /:/,  $time;
	my ($dh, $dm, $ds) = split /:/,  $dur;

	$ts += $ds;
	if($ts >= 60.000000000) {
	    $ts = $ts - 60.000000000;
	    $dm++;
	}
	$tm += $dm;
	if($tm >= 60) {
	    $tm = $tm - 60;
	    $dh++;
	}
	$th += $dh;
	return sprintf("%02d:%02d:%02.9f",$th,$tm,$ts);
    }
